pipeline {
    agent any

    environment {
        DOCKER_HUB    = "anas025"                   // Docker Hub username
        IMAGE_NAME    = "for-docker-app"            // Docker Hub repo name
        IMAGE_TAG     = "prod-${BUILD_NUMBER}"      // Version tag (auto from Jenkins)
        FULL_IMAGE    = "${DOCKER_HUB}/${IMAGE_NAME}:${IMAGE_TAG}"
        LATEST_IMAGE  = "${DOCKER_HUB}/${IMAGE_NAME}:prod-latest"
        BACKUP        = "${DOCKER_HUB}/${IMAGE_NAME}:prod-last" // last working image
        NAMESPACE     = "prod"                       // Kubernetes namespace
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: 'main',
                    url: 'https://github.com/flutterdeveloper2025-tech/Docker_registry.git'
            }
        }

        stage('Approval for PROD') {
            steps {
                input message: 'Deploy to PROD?'
            }
        }

        stage('Setup Kubeconfig') {
            steps {
                withCredentials([file(credentialsId: 'kubernetes_config', variable: 'KUBECONFIG_FILE')]) {
                    sh """
                    mkdir -p \$HOME/.kube
                    cp \$KUBECONFIG_FILE \$HOME/.kube/config
                    chmod 600 \$HOME/.kube/config
                    """
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                sh """
                docker build -t $FULL_IMAGE .
                docker tag $FULL_IMAGE $LATEST_IMAGE
                """
            }
        }

        stage('Docker Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'docker_registry_prod',
                    usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                    sh "echo \$PASS | docker login -u \$USER --password-stdin"
                }
            }
        }

        stage('Push Image to Docker Hub') {
            steps {
                sh """
                docker push $FULL_IMAGE
                docker push $LATEST_IMAGE
                """
            }
        }

        stage('Deploy to Kubernetes PROD') {
            steps {
                withEnv(["KUBECONFIG=$HOME/.kube/config"]) {
                    // Update prod deployment file with new image
                    sh "sed -i 's|image:.*|image: $FULL_IMAGE|' k8s/prod-deployment.yaml"

                    // Apply deployment and service
                    sh "kubectl apply -f k8s/prod-deployment.yaml -n $NAMESPACE"
                    sh "kubectl apply -f k8s/prod-service.yaml -n $NAMESPACE"
                }
            }
        }

        stage('Smoke Test') {
            steps {
                withEnv(["KUBECONFIG=$HOME/.kube/config"]) {
                    script {
                        def retries = 12     // retry 12 times
                        def wait = 10        // wait 10 seconds between retries
                        def externalIP = ""
                        for (int i = 0; i < retries; i++) {
                            externalIP = sh(
                                script: "kubectl get svc mywebsite-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}'",
                                returnStdout: true
                            ).trim()
                            if (externalIP) {
                                echo "LoadBalancer IP found: ${externalIP}"
                                break
                            }
                            echo "Waiting for LoadBalancer IP... retry ${i+1}/${retries}"
                            sleep(wait)
                        }

                        if (!externalIP) {
                            echo "âš ï¸ LoadBalancer IP not assigned, rolling back to last working image"
                            sh "kubectl set image deployment/mywebsite mywebsite=$BACKUP -n $NAMESPACE"
                            error("âŒ Deployment failed, rolled back")
                        }

                        def status = sh(
                            script: "curl -o /dev/null -s -w '%{http_code}' http://$externalIP",
                            returnStdout: true
                        ).trim()
                        if (status != "200") {
                            echo "âš ï¸ App not reachable at $externalIP, rolling back"
                            sh "kubectl set image deployment/mywebsite mywebsite=$BACKUP -n $NAMESPACE"
                            error("âŒ Deployment failed, rolled back")
                        }

                        echo "âœ… PROD App running successfully at $externalIP"
                    }
                }
            }
        }
    }

    post {
        success {
            echo "ðŸŽ‰ PROD deployment to Kubernetes successful"
            mail to: 'flutterdeveloper2025@gmail.com',
                 subject: "âœ… PROD Deployment SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                 body: "The PROD deployment completed successfully.\nCheck Jenkins console: ${env.BUILD_URL}"
        }
        failure {
            echo "âŒ PROD deployment failed"
            mail to: 'flutterdeveloper2025@gmail.com',
                 subject: "âŒ PROD Deployment FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                 body: "The PROD deployment failed.\nCheck Jenkins console: ${env.BUILD_URL}"
        }
    }
}
